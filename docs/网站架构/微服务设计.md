# 1. 微服务
一些系统工作的小而自治的服务。


专注于做好一件事
自治性，解耦，正确地剑魔服务和API

好处：技术异构性，弹性（不可用和功能降级问题）,扩展，简化部属，与组织结构相匹配，可组合性，对可替代性的优化，

1.3 面相服务的架构SOA

# 2. 演化式架构师
职责：愿景，同理心，合作，适应性，自治性，治理

# 3. 如何建模服务
什么样的服务是好服务：
低耦合：修改一个服务无需修改另一个服务。限制两个服务之间的不同调用形式的数量
高内聚:相关的行为聚集一起

3.3限界上下文
共享的隐藏模型（领域驱动设计）
模块和服务:服务边界和领域的限界上下文保持一致
过早划分：

3.4 业务功能
建模服务时，应该将这些功能作为关键操作提供给其他协作者（其他服务）

3.5 逐步划分上下文

3.6 关于业务概念的沟通
修改系统的目的是为了满足业务需求
技术边界：

# 4.集成
4.1寻找理想的集成技术
避免破坏性修改
保证API的技术无关性
使你的服务易于消费方式用
隐藏内部实现细节
为用户创建接口
共享数据库

4.4同步异步
4.5编排与协同
编排： 依赖于某个中心大脑指导并且驱动整个流程
协同：告知系统中各个部分的职责，细节留给他们自己。发布订阅。降低耦合度，但是需要对业务流程做跨服务监控。RPC 和 REST

4.6远程过程调用
缺点： 技术的耦合；本地调用和远程调用并不相同；脆弱性

4.7 REST

4.8实现基于事件的异步协作方式
微服务发布事件机制和消费者接受事件机制
尽量让消息中间件保持简单，把业务逻辑放在自己的服务中
关联ID对跨进程间的请求进行追踪

4.9 服务即状态机
4.10响应式扩展

4.11微服务世界中的DRY 和代码重用的危险：
跨服务可以适度违反DRY

语义化版本控制 MAJOR.MINOR.PATCH。通过语义化版本控制可以直接看出来是否有不兼容修改，调用方是否需要修改调用点代码。


# 5.分解单块系统

通过限界上下文来确定业务拆分边界。

SchemaSpy 工具生成数据库之间的关系图

拆除外键：通过API 来提供访问。（这样做会增加请求减慢访问速度，需要做个权衡）
作者这里推荐先做数据库拆分，之后去拆分业务代码。

数据库重构: 拆分过程可以根据业务边界重新设计db

拆分之后如何处理事务不一致问题：

- 再试一次，比如一个操作成功了，一个失败了。但是要保证重试可以修复这个问题(最终一致性)
- 终止整个操作。发起一个补偿事务抵消之前的操作，但是补偿也可能失败，不好处理，可能需要一个后台
- 分布式事务：两阶段提交.尽量用现有的技术方案

把设计画在白板上，在你认为的服务边界上运行用例，看看会发生什么。

CRC(class-responsibility-collaboration): 类、职责、交互卡片


# 6 部署

CI (continuous intergration) 持续集成

- 是否每天签入代码到主线
- 是否有一组测试验证修改
- 构建失败后，是否把修复 CI 当做第一优先级事情来做

CD(continuous delivery) 持续交付
