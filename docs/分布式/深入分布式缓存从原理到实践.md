# 1 缓存为王

页表(page table)和内存管理单元(MMU)负责将虚拟地址转化为页的物理地址。
页表负责记录哪些是物理页，哪些是虚拟页，以及这些页的页表条目(PTE)。
MMU是一个物理硬件，负责进行虚拟地址到物理地址的翻译，翻译过程中需要从页表获取页的
PTE，MMU也会使用翻译后备缓存(TLB)的缓存页号。

系统性能指标：响应时间、延迟时间、吞吐量，并发用户数和资源利用率等

### 浏览器缓存

Cache-Control/Exires 优先级高于 Last-Modified/ETag，当本地副本根据 Cache-Control/Expires 发现还在有效期，
就不会再次发送请求服务器询问修改时间(Last-Modified)或实体标识(e-tag)了。

主流的缓存算法：
- LRU(Least-Recently-Used): 替换掉最近请求最少的对象，实际中使用最广。cpu缓存淘汰和虚拟内存效果好，web应用欠佳
- LFU(Least-Frequently-Used): 缓存污染问题(一个先前流行的缓存对象会在缓存中驻留很长时间)
- LRU2
- 2Q(two queues)。多级缓存
- SIZE：替换占用空间最大的。也会有缓存污染
- LRU-Threashold：不超过某一个size 的，其他与 LRU 相同
- Log(Size) + LRU: 替换 size 最大的对象，当size相同按 LRU 替换
- Hyper-G: LFU 改进版，同时考虑上次访问时间和对象 size
- Pitkow/Recker: 替换最近最少使用对象，除非所有对象都是今天访问过的。如果是，替换调最大的对象
- Lowest-Latency-First: 替换下载时间最少的，最小化平均延迟
- Hybrid Hybrid: 保留效用最低的会被替换掉
- Lowest Relative Value(LRV): 替换保留效用最低的
- Adaptive Replacement Cache(ARC)
- Most Recently Used(MRU)
- First in First out(FIFO)
- Random Cache


# 5 Memcached 集中式缓存
特性：

- 协议简单：基本文本或者二进制协议
- libevent 事件处理
- 内存存储空间
- 客户端分布式。客户端实现，服务端并不支持分布式

不足：

- 无法备份（易失）。只能通过持久化解决
- 不支持条件查询
- 没有内置安全机制
- 单点故障 failover。可以通过主从解决


内存管理: Slab Allocation。按照预先规定大小，将分配的内存分割成各种尺寸的块(chunk)，并把尺寸相同的块分成组(chunk集合)，
分配的块可以重复利用，不释放到内存

- Page: 分配给 Slab 的内存空间，默认 1 MB
- Chunk： 用于缓存记录的内存空间
- Slab class： 特定大小的 chunk 组

典型问题：
- 容量问题
- 服务高可用(HA)
- 扩展问题

两种过期机制：

- lazy expiration: get时候查看是否过期，不直接监视
- LRU

哈希算法：任意长度的输入，通过散列算法，变换成固定长度的输出。
使用一致性哈希很好解决动态环境下的使用 Memcached 扩缩容带来的大量数据失效的问题。

热点问题：
如果是超高访问的热点数据
- 通用解决思路就是 client 端做本地的 LocalCache（放到进程缓存里），省去了缓存服务器IO。
- 通过多个 key_index 分散到多个机器上，减少针对一个server 的超高访问。


缓存与数据库的更新问题：
更新数据库成功，删除cache失败。别把缓存当存储，分布式架构一切都可能fail。

命名空间：通过前缀等来模拟

CAS(Check and Set): 解决原子操作问题。比如用户操作一个key对应的value，需要保证操作当中，value不允许被其他访问操作，
如果被操作过，则操作失败。
首先用 gets 指令获取 key-value 及 key 对应 value 的版本号version，然后操作产生新的value；最后使用 CAS
指令重新提交key-value，并附带之前的版本号version。服务端判断CAS操作中的version不是最新，认为key被改，本次CAS操作失败。


客户端：协议封装，连接池，sharding，故障转移，序列化


周边工具：
- The innoDB memcached Plugin
- Twemcache
- Twemproxy: 快速的单线程代理程序
- MemcacheDB/MemcacheQ/Mcrouter
- Tokyo Cabinet: DBM 数据库


# 6 Memcached 周边
可扩展、高可用、可维护性

### Twemcache

### Twemproxy
单线程代理程序，支持memcached ASCII 协议和Redis
协议。c语言编写，通过引入一个代理层，将应用程序后端多个redis或者membcached
实例进行统一管理。应用程序只需要在Wwemproxy上进行操作即可。

- 支持失败节点自动删除
- 支持设置Hash Tag
- 保持与缓存服务器长连接，减少直接连接数
- 支持多种hash 算法
- 支持状态监控
- 连接复用和内存复用

LVS(keepalived,双节点热备保证LVS高可用) -> Twemproxy -> cache(缓存自身高可用)

# 7 Redis 探秘


