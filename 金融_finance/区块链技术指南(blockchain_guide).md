https://yeasy.gitbooks.io/blockchain_guide 读书笔记

# 区块链思想的诞生与概念

## 从数字货币说起
双重支付攻击：持有人可以试图将同一份电子货币发给多个人。
当前银行中电子化货币假定存在一个安全可靠的第三方机构来实现，这个机构利用信用作为抵押，来完成交易。

去中心化场景下存在几个难题：
- 货币的防伪
- 货币交易
- 避免双重支付

数字货币的几代演进：
- 1983年 ecash，依赖中心化的中介机构，最终失败
- 1997, Hashcash. 首次提出工作量证明(Proof of Work, PoW)机制获取额度，该技术后来被后续数字货币技术采用
- 1998, B-money. 将POW 引入数字货币生成，同时是首个面向去中心化的设计，但是未能提出具体实现
- 比特币，PoW 与共识机制结合在一起

目前数字货币两种模式：paypal跟已有系统合作，成为代理；一种是比特币这样的完全丢弃已有体系的分布式技术

什么是比特币：
2008年10月31，化名为中本聪提出了比特币设计白皮书，并在2009年公开了最初的代码实现，第一个比特币是2009年
1月31日 18：15：05 生成。作为一种概念金融货币，比特币主要是希望解决已有金融货币系统的几个问题：
- 被掌握在发型机构手中
- 自身价值无法保证
- 无法匿名交易

比特币到区块链：
实现去中心化记账本系统的一种极具潜力的可行技术。
区块链属于一种去中心化的记录技术，参与到系统上的节点，可能不属于同一组织彼此无需信任，区块链数据由所有节点共同维护，
每个节点都能复制获取一份完整记录的拷贝。和传统的记账技术相比其特点包括：
- 维护一条不断增长的链，只能添加记录，发生过的记录都不可篡改
- 去中心化（多中心化）
- 通过密码学机制确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性


区块链基本原理:
- 交易(Transaction): 一次操作，导致账本状态的一次改变，如添加一条记录
- 区块(Block): 记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识
- 链(Chain): 由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录

以比特币看如何使用区块链技术：
客户端发起一项交易后，会广播到网络中等待确认。网络中的节点会讲一些等待确认的交易记录打包在一起（还要包括此前区块的哈希值等信息），
组成一个候选区块。然后试图找打一个 nonce 串放到区块里，使得候选区块的hash值结果满足一定条件（比如小于某个值）。
一旦算出来这个区块在格式上就合法了，就可以进行全网广播。大家拿到提案区块，进行验证，发现确实符合约定条件了，就承认这个区块是一个
合法的新区块，被添加到链上。
比特币的这种基于算力的共识机制被称为Proof of
Work(PoW)。目前要让hash结果满足一定的条件并无已知的启发式算法，只能暴力尝试。
尝试次数越多算出来的概率越大。通过调节对hash结果的限制，比特币网络控制月10分钟平均算出一个合法区块。
算出来的节点将得到区块中所有交易的管理费和协议固定发放的奖励费（每4年减半），也俗称挖矿。

区块链分类，根据参与者不同，可以分为：
 - 公开链：任何人都可以参与使用和维护，比如比特币
 - 私有链：集中管理者进行限制，内部少数人可以使用，信息不公开
 - 联盟链：若干组织一起合作维护一条区块链


# 区块链技术的价值、挑战与展望

### 价值
技术上说区块链一般被认为具有：
- 分布式容错
- 不可篡改
- 隐私保护

随之带来的业务特性包括：
- 可信任性
- 降低成本
- 增强安全

### 关键技术和挑战
- 密码学技术
- 分布式共识：核心在于如何解决某个变更在网络中是一致的，是被大家都承认的。经典的拜占庭算法等，可以解决确定性问题
- 处理性能。提高交易吞吐量，降低交易确认延迟
- 扩展性:网络节点数过多可能会因为一致性达成过车概念延迟降低整个网络的性能
- 系统安全。立法监管；软件漏洞
- 数据库和存储系统。
- 可集成性。如何与现有系统共存
- 其他：运营问题


## 典型应用场景
区块链在不引入第三方中介机构的前提下，可以提供去中心化、不可篡改、安全可靠等特性保证。所有直接或间接依赖于第三方担保信任机构的活动，
均可从区块链技术中获益。
### 金融服务。降低交易成本，减少跨组织交易风险等

交易本质上交换的是价值的所属权。
银行金融管理；支付服务；证券交易

### 征信和权属管理
- 征信管理：区块链天然无法篡改、不可抵赖的特性
- 权属管理：产权、版权等所有权的管理和追踪

### 资源共享: airbnb，降低管理成本
问题主要包括：成本高、用户身份评分难、共享服务管理难
短租共享；社区能源共享; 电商平台；大数据共享

### 投资管理：降低管理成本和管控风险
跨境交易；一带一路；众筹投资

### 物联网与供应链
物流供应链；公共网络服务

# 分布式系统

### 一致性问题
分布式系统中一致性(Consistency)指对于系统中多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得
他们对处理结果达成某种程度的一致。一致性不代表结果正确与否，而是系统对外呈现的状态是否一致。
将可能引发不一致的并行操作进行串行化，就是现代计算机系统里处理分布式一致性问题的基础思路和唯一秘诀。
规范的说，理想的分布式系统一致性应该满足：
- 可终止性（Termination）：一致的结果在有限时间内能完成；
- 共识性（Consensus）：不同节点最终完成决策的结果应该相同；
- 合法性（Validity）：决策的结果必须是其它进程提出的提案。

强一致性主要包括两类：
- 顺序一致性:保证所有进程看到的 全局执行顺序（total order）一致，并且每个进程看自身的执行（local order）跟实际发生顺序一致
- 线性一致性: 顺序一致性前提下加强了进程间的操作排序，形成唯一的全局顺序（系统等价于是顺序执行，所有进程看到的所有操作的序列顺序都一致，并且跟实际发生顺序一致），是很强的原子性保证。但是比较难实现，目前基本上要么依赖于全局的时钟或锁，要么通过一些复杂算法实现，性能往往不高。

弱一致性：最终一致性

### 共识算法
共识算法解决的是对某个提案（Proposal），大家达成一致意见的过程。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是领导……等等，可以认为任何需要达成一致的信息都是一个提案。
一般地，把故障（不响应）的情况称为“非拜占庭错误”，恶意响应的情况称为“拜占庭错误”（对应节点为拜占庭节点）。
常见算法：针对非拜占庭错误的情况，一般包括 Paxos、Raft 及其变种。
对于要能容忍拜占庭错误的情况，一般包括 PBFT 系列、PoW 系列算法等。从概率角度，PBFT 系列算法是确定的，一旦达成共识就不可逆转；而 PoW 系列算法则是不确定的，随着时间推移，被推翻的概率越来越小。

### FLP 不可能性原理

即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题的下限是无解。
这个结论，被称为 FLP 不可能性 原理，可以看做分布式领域的“测不准原理”:
FLP 不可能原理：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。

但是工程上，付出 一些代价，把它变成可能。回答这个问题的是另一个很出名的原理：CAP原理

### CAP 原理
分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。

- 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性；
- 可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求；
- 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。

比较直观地理解，当网络可能出现分区时候，系统是无法同时保证一致性和可用性的。要么，节点收到请求后因为没有得到其他人的确认就不应答，要么节点只能应答非一致的结果。
好在大部分时候网络被认为是可靠的，因此系统可以提供一致可靠的服务；当网络不可靠时，系统要么牺牲掉一致性（大部分时候都是如此），要么牺牲掉可用性。

弱化一致性：对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。 例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。
弱化可用性：对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。 Paxos、Raft 等算法，主要处理这种情况。
弱化分区容忍性: 现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。

### ACID 原则

即 Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）。

ACID 原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价。

- Atomicity：每次操作是原子的，要么成功，要么不执行；
- Consistency：数据库的状态是一致的，无中间状态；
- Isolation：各种操作彼此互相不影响；
- Durability：状态的改变是持久的，不会失效。

一个与之相对的原则是 BASE（Basic Availiability，Soft state，Eventually Consistency），牺牲掉对一致性的约束（最终一致性），来换取一定的可用性。

### Paxos 与 Raft
Paxos 问题是指分布式的系统中存在故障（fault），但不存在恶意（corrupt）节点场景（即可能消息丢失或重复，但无错误消息）下的共识达成（Consensus）问题。因为最早是 Leslie Lamport 用 Paxon 岛的故事模型来进行描述而命名。

#### Paxos
Paxos 是第一个被证明的共识算法，其原理基于 两阶段提交 并进行扩展。

作为现在共识算法设计的鼻祖，以最初论文的难懂（算法本身并不复杂）出名。算法中将节点分为三种类型：

- proposer：提出一个提案，等待大家批准为结案。往往是客户端担任该角色；
- acceptor：负责对提案进行投票。往往是服务端担任该角色；
- learner：被告知结案结果，并与之统一，不参与投票过程。可能

并且，算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：

- safety：保证决议结果是对的，无歧义的，不会出现错误情况。
决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；
在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；
- liveness：保证决议过程能在有限时间内完成。
决议总会产生，并且 learners 能获得被批准（chosen）的决议。

Paxos 能保证在超过的正常节点存在时，系统能达成共识。

###### 单个提案者+多接收者
如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。
但一旦提案者故障，则系统无法工作。

###### 多个提案者+单个接收者

限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。
缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。
以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。
当提案者和接收者都推广到多个的情形，会出现一些挑战。

###### 多个提案者+多个接收者
既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。
一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。
另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。

如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。
此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。

###### 两阶段提交
Paxos 里面对这两个阶段分别命名为准备（prepare）和提交（commit）。准备阶段解决大家对哪个提案进行投票的问题，提交阶段解决确认最终值的问题。

准备阶段：

提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多数接受者的支持。
接受者时刻保留收到过提案的最大编号和接受的最大提案。如果收到的提案号比目前保留的最大提案号还大，则返回自己已接受的提案值（如果还未接受过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接受小于最大提案号的提案。

提交阶段：

提案者如果收到大多数的回复（表示大部分人听到它的请求），则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功，则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没收到足够多的回复，则需要再次发出请求。
接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。

一旦多数接受了共同的提案值，则形成决议，成为

#### Raft
Raft 是 Paxos 算法的一种简化实现。
包括三种角色：leader、candidate 和 follower，其基本过程为：

- Leader 选举：每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；
- 同步 log：leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；( 此处 log
  并非是指日志消息，而是各种事件的发生记录。)

### 拜占庭问题与算法

#### 拜占庭问题
拜占庭问题更为广泛，讨论的是允许存在少数节点作恶（消息可能被伪造）场景下的一致性 达成问题。拜占庭算法讨论的是最坏情况下的保障。

拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。
拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。

对于拜占庭问题来说，假如节点总数为 N，叛变将军数为 F，则当 N >= 3F+1 时，问题才有解，即 Byzantine Fault Tolerant (BFT) 算法。

#### Byzantine Fault Tolerant 算法
面向拜占庭问题的容错算法，解决的是网络通信可靠，但节点可能故障情况下的一致性达成。
最早由 Castro 和 Liskov 在 1999 年提出的 Practical Byzantine Fault Tolerant（PBFT）是第一个得到广泛应用的 BFT 算法。只要系统中有  的节点是正常工作的，则可以保证一致性。
PBFT 算法包括三个阶段来达成共识：Pre-Prepare、Prepare 和 Commit。

#### 新的解决思路
拜占庭问题之所以难解，在于任何时候系统中都可能存在多个提案（因为提案成本很低），并且要完成最终的一致性确认过程十分困难，容易受干扰。但是一旦确认，即为最终确认。
比特币的区块链网络在设计时提出了创新的 PoW（Proof of Work）工作量证明算法思路。一个是限制一段时间内整个网络中出现提案的个数（增加提案成本），另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。系统的最终确认是概率意义上的存在。这样，即便有人试图恶意破坏，也会付出很大的经济代价（付出超过系统一半的算力）。
后来的各种 PoX 系列算法，也都是沿着这个思路进行改进，采用经济上的惩罚来制约破坏者。

### 可靠性指标
一般来说，单点的服务器系统至少应能满足两个九；普通企业信息系统三个九就肯定足够了（大家可以统计下自己企业内因系统维护每年要停多少时间），系统能达到四个九已经是业界领先水平了（参考 AWS）。电信级的应用一般号称能达到五个九，这已经很厉害了，一年里面最多允许五分钟的服务停用。六个九和以上的系统，就更加少见了，要实现往往意味着极高的代价。
那么，该如何提升可靠性呢？有两个思路：一是让系统中的单点变得更可靠；二是消灭单点。


# 密码学技术

### Hash 算法
Hash （哈希或散列）算法是信息技术领域非常基础也非常重要的技术。它能任意长度的二进制值（明文）映射为较短的固定长度的二进制值（Hash 值），并且不同的明文很难映射为相同的 Hash 值。
例如计算一段话“hello blockchain world, this is yeasy@github”的 MD5 hash 值为 89242549883a2ef85dc81b90fb606046。
hash 值在应用中又被称为指纹（fingerprint）、摘要（digest）。 注：MD5 是一个经典的 hash 算法，其和 SHA-1 算法都已被 证明 安全性不足应用于商业场景。

一个优秀的 hash 算法，将能实现：

- 正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。
- 逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。
- 输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。
- 冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。

  目前，一般认为 MD5 和 SHA1 已经不够安全，推荐至少使用 SHA2-256 算法。

一般的，Hash 算法都是算力敏感型，意味着计算资源是瓶颈，主频越高的 CPU 进行 Hash 的速度也越快。
也有一些 Hash 算法不是算力敏感的，例如 scrypt，需要大量的内存资源，节点不能通过简单的增加更多 CPU 来获得 hash 性能的提升。

### 加解密算法

| 算法类型   | 特点                   | 优势                   | 缺陷                             | 代表算法                       |
|------------|------------------------|------------------------|----------------------------------|--------------------------------|
| 对称加密   | 加解密密钥相同或可推算 | 计算效率高，加密强度高 | 需提前共享密钥；易泄露           | DES、3DES、AES、IDEA           |
| 非对称加密 | 加解密密钥不相关       | 无需提前共享密钥       | 计算效率低，仍存在中间人攻击可能 | RSA、ElGamal、椭圆曲线系列算法 |

#### 对称加密
顾名思义，加解密的密钥是相同的。
优点是加解密效率高（速度快，空间占用小），加密强度高。
缺点是参与多方都需要持有密钥，一旦有人泄露则安全性被破坏；另外如何在不安全通道下分发密钥也是个问题。
对称密码从实现原理上可以分为两种：分组密码和序列密码。前者将明文切分为定长数据块作为加密单位，应用最为广泛。后者则只对一个字节进行加密，且密码不断变化，只用在一些特定领域，如数字媒介的加密等。
代表算法包括 DES、3DES、AES、IDEA 等。

#### 非对称加密
非对称加密是现代密码学历史上最为伟大的发明，可以很好的解决对称加密需要的提前分发密钥问题。
顾名思义，加密密钥和解密密钥是不同的，分别称为公钥和私钥。
公钥一般是公开的，人人可获取的，私钥一般是个人自己持有，不能被他人获取。
优点是公私钥分开，不安全通道也可使用。
缺点是加解密速度慢，一般比对称加解密算法慢两到三个数量级；同时加密强度相比对称加密要差。
非对称加密算法的安全性往往需要基于数学问题来保障，目前主要有基于大数质因子分解、离散对数、椭圆曲线等几种思路。
代表算法包括：RSA、ElGamal、椭圆曲线（Elliptic Curve Crytosystems，ECC）系列算法。

一般适用于签名场景或密钥协商，不适于大量数据的加解密。 RSA 算法等已被认为不够安全，一般推荐采用椭圆曲线系列算法。

#### 混合加密机制

即先用计算复杂度高的非对称加密协商一个临时的对称加密密钥（会话密钥，一般相对内容来说要短的多），然后双方再通过对称加密对传递的大量数据进行加解密处理。
典型的场景是现在大家常用的 HTTPS 机制。HTTPS 实际上是利用了 Transport Layer Security/Secure Socket Layer（TLS/SSL）来实现可靠的传输。TLS 为 SSL 的升级版本，目前广泛应用的为 TLS 1.0，对应到 SSL 3.1 版本。

建立安全连接的具体步骤如下：
- 客户端浏览器发送信息到服务器，包括随机数 R1，支持的加密算法类型、协议版本、压缩算法等。注意该过程为明文。
- 服务端返回信息，包括随机数 R2、选定加密算法类型、协议版本，以及服务器证书。注意该过程为明文。
- 浏览器检查带有该网站公钥的证书。该证书需要由第三方 CA 来签发，浏览器和操作系统会预置权威 CA 的根证书。如果证书被篡改作假（中间人攻击），很容易通过 CA 的证书验证出来。
- 如果证书没问题，则用证书中公钥加密随机数 R3，发送给服务器。此时，只有客户端和服务器都拥有 R1、R2 和 R3 信息，基于 R1、R2 和 R3，生成对称的会话密钥（如 AES 算法）。后续通信都通过对称加密进行保护。
